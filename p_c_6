fn gcd(mut a: u32, mut b: u32) -> u32 {
    while b != 0 {
        let t = b;
        b = a % b;
        a = t;
    }
    a
}

fn main() {
    let result1 = gcd(15, 6);
    let result2 = gcd(60, 24);

    println!("The greatest common divisor of 15 and 6 is {}", result1);
    println!("The greatest common divisor of 60 and 24 is {}", result2);

    assert_eq!(result1, 3); 
    assert_eq!(result2, 12);  
    
    println!("All tests passed!");
}

Спочатку я створив функцію gcd, яка приймає два числа a і b. Обидва числа є змінними, тому я використав mut, щоб змінювати їх під час роботи алгоритму.

Я вирішив використовувати цикл while, який буде працювати доти, поки значення b не дорівнюватиме нулю. Кожного разу в циклі я зберігаю поточне значення b в змінну t, а потім змінюю значення b на залишок від ділення a на b. Після цього a приймає значення змінної t. Так цикл продовжує виконуватися, доки не знайде найбільший спільний дільник.

У функції main я перевіряю правильність роботи функції gcd, використовуючи assert_eq!. Це дозволяє перевірити, чи дорівнює результат роботи функції очікуваному значенню.

Для наочності я додав рядок println!("All tests passed!");, щоб вивести повідомлення, якщо всі перевірки пройдуть успішно.
